{"name":"COMPSCI 101","tagline":"Introduction to Computers and Programming (Version 0.4 Alpha)","body":"## Go!\r\n\r\n![go_robo](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch1/robo.png)\r\n\r\nHere is Robo, maybe we will build him one day.\r\n\r\n![go_hardware](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch1/go_hardware.png)\r\n\r\nHe has a central processing unit somewhere inside his head that reads computer programs and runs them, and some flash memory where all of the computer programs are stored.\r\n\r\n\t$ check hardware\r\n    Checking hardware...\r\n    CPU installed\r\n    Flash Memory installed\r\n    Everything is OK!\r\n\r\nThis is the terminal where we enter our commands and communicate with Robo.\r\n\r\n![go_speak](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch1/go_speak.png)\r\n\r\nHe doesn't understand the language we speak, he only understands Robo Language 1.0, which is installed in the flash memory.\r\n\r\nRobo Language 1.0 looks like this:\r\n\r\n![go_1.0](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch1/go_1.0.png)\r\n\r\nWe can write a program using the arrows as our code to move Robo.\r\n\r\n![go_level1](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch1/go_level1.png)\r\n\r\n> Write a move.bot program, upload it to Robo and then run the program.\r\n\r\n    Uploading program move.bot to Flash Memory\r\n\r\n    Reading program move.bot from Flash Memory\r\n    Running program move.bot\r\n\r\nUsually programs are typed on computers with keyboards and usually programming languages are made up of those keyboard characters.\r\n\r\nLet's update our software to Robo Language 2.0 using the terminal.\r\n\r\n    $ update robo-lang\r\n    Updating robo-lang to version 2.0\r\n    Update complete!\r\n\r\nRobo Language 2.0 looks like this:\r\n\r\n    step 2\t\t\t// step forward two spaces\r\n    turn right\t\t// turn right 90 degrees\r\n\r\nLet's program Robo to get back to the start.\r\n\r\n![go_level2](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch1/go_level2.png)\r\n\r\n    $ upload move.bot\r\n    Uploading program move.bot to Flash Memory\r\n\r\n    $ run move.bot\r\n    Reading program move.bot from Flash Memory\r\n    Running program move.bot\r\n\r\nLet's get ready for the next course.\r\n\r\n![go_level3](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch1/go_level3.png)\r\n\r\nA big crack has appeared in Robo's path! But we do not have an instruction that can get him over it. In programming you can code new ways to do things. What we need is more control over Robo.\r\n\r\n    $ update robo-lang\r\n    Updating robo-lang to version 3.0\r\n    Update complete!\r\n\r\nRobo Language 3.0 looks like this:\r\n\r\n    // Importing Robo Language 3.0 function which jumps Robo over one space\r\n    import legs.jump\r\n\r\n    jump() :           // New jump function\r\n      legs.jump()\r\n\r\n    jump()             // Using jump function\r\n    step(2)\r\n    turn(90)\r\n\r\n<br>\r\n\r\n    $ upload move.bot\r\n    Uploading program move.bot to Flash Memory\r\n\r\n    $ run move.bot\r\n    Reading program move.bot from Flash Memory\r\n    Running program move.bot\r\n\r\nRobo was taking awhile to process our new instructions. It is time we upgraded his hardware.\r\n\r\n![go_hardware](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch1/go_hardware.png)\r\n\r\nInside Robo's head is the CPU that reads and runs our program and the flash memory where we are storing our program. As a program gets bigger more and more instructions are being read from our program. We are using flash memory to store our program but this can be slow to read from. A type of fast memory is called RAM. RAM is fast to read and write to but when the power goes off everything is erased.\r\n\r\nWe will store our program in flash memory, when we run our program the CPU will copy the program from flash memory to RAM, and then the CPU will read our instructions faster from RAM. Let's install some RAM.\r\n\r\n![go_hardware_ram](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch1/go_hardware_ram.png)\r\n\r\n    $ check hardware\r\n    Checking hardware...\r\n    CPU installed\r\n    Flash Memory installed\r\n    RAM installed\r\n    Everything is OK!\r\n\r\n    $ run move.bot\r\n    Copying program move.bot from Flash Memory to RAM\r\n    Reading program move.bot from RAM\r\n    Running program move.bot\r\n\r\nWe are ready to begin COMPSCI 101 and learn to...\r\n\r\n![go_hacker](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch1/go_hacker.png)\r\n\r\nWait! Somebody is hacking into Robo!\r\n\r\nTo stop somebody else programming Robo we need security.\r\n\r\n    $ set password\r\n    Enter Password:\r\n    Confirm Password:\r\n    Password Set!\r\n\r\n![go_hacker_no](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch1/go_hacker_no.png)\r\n\r\nTake that hacker!\r\n\r\nGood, now we have had a taste of what this course is all about. Let's move on.\r\n\r\n## What's in the Course\r\n\r\nWe are going to be **thinking like a computer**. That is more of what we have been doing so far with Robo Language 1.0 and also looking at binary 1010 0110, no it is not the Matrix but how computers understand.\r\n\r\nWe are going to be taking a **look inside computers**. That is adding to our list of hardware: CPU, flash memory, RAM, hard drive, disk drive, power supply and more.\r\n\r\nWe are going to be **using any computer** in front of us. That is navigating an operating system, learning how to use our software, understanding the magic behind files and getting down and dirty with the command line.\r\n\r\nWe are going to be **programming**. First learning the basics with Robo Language 2.0 and then delving into the programming languages of games, the web, and electronics - we will do it all while coding our own calculator, games, website and by blinking some LEDs.\r\n\r\nWe are going to be taking our **security and privacy** seriously. That is creating strong passwords, deciding what information to share online and looking at the realities of the internet.\r\n\r\nFinally we will discuss **copyright and ethics** in computing and decide on the kind of world we want to live and code in.\r\n\r\nGood, now we have an idea of what is to come in this course. Let's move on.\r\n\r\n## Thinking Like a Computer\r\n\r\nA computer is perfect. It will follow every instruction you give, and never complain, unlike your little brother or sister. This is what makes a computer so great, and also so annoying. You see it will follow every instruction you give, and never complain, not even if you tell it to blow itself up! So you better be careful what you tell it to do, because a computer is perfect.\r\n\r\n![think_level1](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch3/think_level1.png)\r\n\r\nWe want to move Robo to the other side of the wall. It looks like we cannot move forward - we have to turn. If we tell Robo to step forward instead of turn he will definitely walk straight into the wall.\r\n\r\n![think_level2](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch3/think_level2.png)\r\n\r\nOuch! Sorry Robo. We need to be careful with our instructions.\r\n\r\n![go_1.0](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch3/go_1.0.png)\r\n\r\nThese instructions we are writing are part of Robo Language 1.0. Robo Language 1.0 is a complete set of instructions that Robo understands. We will learn more of the set as we go.\r\n\r\nWhen we write a set of instructions for a computer it is called coding - we are writing code.\r\n\r\n![think_level3](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch3/think_level3.png)\r\n\r\n![think_1.0_function](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch3/think_1.0_function.png)\r\n\r\nThe instruction above tells Robo to step forward three spaces. We can use this type of notation with all of the Robo Language 1.0 instructions to shorten our code.\r\n\r\n![think_level4](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch3/think_level4.png)\r\n\r\n![think_1.0_jump](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch3/think_1.0_jump.png)\r\n\r\nThe instruction above tells Robo to jump over one space.\r\n\r\nPerfect isn't he. Little Robo does what he's told.\r\n\r\nSo why is it that he follows instructions like that? Well at a very basic level Robo like any computer thinks in only two ways: on and off.\r\n\r\n![think_binary](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch3/think_binary.png)\r\n\r\nThis is what we call binary. Often binary is explained as ones and zeroes, but all this is really telling us is that there are only two ways of doing something - either the thing is on (1) or it is off (0).\r\n\r\n![think_binary_switch](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch3/think_binary_switch.png)\r\n\r\nHave you ever seen a power switch with a 1 and 0 on it? This let's us know when the power is on or off and is the same way a computer works at a very basic level.\r\n\r\nSo how does this explain how a computer thinks because they can do a lot more than just turn on and off? That's true and it is because of a lot of offs and ons. Let's start with what one on/off looks like and build up.\r\n\r\n![think_binary_light](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch3/think_binary.png)\r\n\r\nA light switch is the best on/off example to look at and is literally on and off. When the switch is in the off position there is a space between two bits of metal and no electricity can flow in the circuit, so a dark room for us. When the switch is flicked on the two bits of metal touch, electricity begins to flow and we can see.\r\n\r\n![think_binary_3light](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch3/think_binary_3light.png)\r\n\r\nNow let's triple the amount of lights! One lightbulb is red, one is green and one is blue and they are all right next to each other and each light has its own switch. Light is cool because we can combine colours to make other colours, like mixing paint but sort of reverse. Anyway if we turn the red and green lights on and keep the blue light off we get yellow light. If we turn the red light off but keep the green and blue on we get cyan, a nice sky blue looking one.\r\n\r\nThree switches, three ons and offs, multiple combinations - or codes?\r\n\r\nYes codes!\r\n\r\nRed on, green on, blue off, is yellow. So in terms of switches: on, on, off = yellow. And remember sometimes on a switch, 1 is for on and 0 is for off. So 110 = yellow.\r\n\r\n![think_rgb](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch3/think_rgb.png)\r\n\r\nHere is the full colour model for visible light.\r\n\r\n|Letter|Binary     |\r\n|------|-----------|\r\n| A    | 0100 0001 |\r\n| B    | 0100 0010 |\r\n| C    | 0100 0011 |\r\n| D    | 0100 0100 |\r\n| E    | 0100 0101 |\r\n| F    | 0100 0110 |\r\n\r\nThis is some of the ASCII alphabet used to represent letters in computers that use text. Each letter is coded in eight bits. A computer can decode the binary and match it to the correct letter.\r\n\r\n\t0100 0010\r\n    0100 0101\r\n    0100 0101\r\n    0100 0110\r\n\r\nThe oppostite of decoding, figuring out the code, is encoding, creating the code.\r\n\r\nThis seems like a lot of work just to make some colours and letters. Luckily we don't have to go so deep inside a computer that we have to manually switch each little thing on and off - we have programming languages like Robo Language 1.0 that somebody has already figured out and given us some easy codes that do a million and one things underneath. But we know that we can go really deep and do it ourselves if we need to.\r\n\r\nGood, now we know a computer is perfect and thinks nothing like us. Let's move on.\r\n\r\n## Looking Inside a Computer\r\n\r\nA computer has stuff inside it and that stuff is called hardware. Is it hardware because it is hard, maybe. And it doesn't matter what computer you look inside because they all have something in common.\r\n\r\n![go_hardware](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch1/go_hardware.png) ![go_robo](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch1/go_robo.png)\r\n\r\nRemember Robo? In the beginning his head had just a CPU and some flash memory inside of it - having something that processes information and something that stores information is pretty common for a computer.\r\n\r\nWhat computer should we look in? Your laptop? Your phone? Yes your phone might be a computer. Some people call them smartphones but if you can tell it to destroy itself and it will, it doesn't sound very smart. No, let us take a look inside a classic desktop computer - the parts are big and easy to get at.\r\n\r\n![inside_pc](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch4/inside_pc.png)\r\n\r\nDo not worry about remembering everything that follows - we will take our time to figure it out. But first we must name each part and build on that.\r\n\r\nThe central processing unit (**CPU**) reads and writes data from the hard drive and RAM, and controls everything in the computer.\r\n\r\nThe **hard drive** is where we store programs that we want to keep after the computer is turned off. It is a type of slow memory.\r\n\r\nThe **RAM** (random access memory) is a type of fast memory used to do things while the computer is turned on. When the computer is turned off everything on the RAM is gone.\r\n\r\nThe **power supply** converts power from the wall socket into something all of the other computer parts use, and feeds the power to all of the other parts.\r\n\r\nThe **disc drives** are used to read and write to optical media which are just CDs and DVDs. Discs use a fascinating form of binary that we will look at.\r\n\r\nThere are many more pieces to a desktop computer: ports for devices, sound and video stuff, network stuff. But the pieces above are the main ones.\r\n\r\nWe are now going to take a look at what these parts can do for a computer by installing more hardware into Robo.\r\n\r\n    $ check hardware\r\n    Checking hardware...\r\n    CPU installed\r\n    Flash Memory installed\r\n    RAM installed\r\n    Everything is OK!\r\n\r\n![go_hardware_ram](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch1/go_hardware_ram.png)\r\n\r\nEarlier we decided to install some RAM into Robo and store our computer program in flash memory, then let the CPU copy the program from flash memory to RAM, and then the CPU read our instructions faster from RAM and Robo did things quicker.\r\n\r\nThis was because flash memory like hard drive memory is slow and RAM is fast. The CPU was the part doing the reading and writing of programs to the different memory.\r\n\r\nWhat I didn't tell you before was that our flash memory is almost full! And we are not going to be able to store any more software on to Robo without deleting something else. What we can do is install a big hard drive, move all of our files from flash onto it and solve all of our issues.\r\n\r\n![inside_hardware_hdd](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch4/inside_hardware_hdd.png)\r\n\r\n    $ copy Flash memory to Hard Drive\r\n    Copying data...\r\n    Complete!\r\n\r\n    $ erase Flash Memory\r\n    Erasing data...\r\n    Complete!\r\n\r\nWe will use the flash memory for something else later.\r\n\r\nSomething else I didn't tell you was Robo is running on a rechargeable battery. This is a bit annoying because to charge the battery we have to take it out of Robo and plug it into a wall charger. What we want is a way to charge our battery while it is installed in Robo. We will use a power supply to do this.\r\n\r\n![inside_hardware_power](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch4/inside_hardware_power.png)\r\n\r\nNow that we have put a power supply into Robo, anytime we want to charge him up we just plug him into the wall. What is important to know is that we need a power supply to convert the voltage amount from the wall into lower voltages that our computer parts run on - otherwise things would be melting, burning and possibly blowing up.\r\n\r\n    $ check hardware\r\n    Checking hardware...\r\n    CPU installed\r\n    Flash Memory installed\r\n    RAM installed\r\n    Hard Drive installed\r\n    Power Supply installed\r\n    Everything is OK!\r\n\r\nTo tie this chapter on hardware to the binary we learnt about earlier we are going to talk about CDs and DVDs.\r\n\r\n![inside_disc](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch4/inside_disc.png)\r\n\r\nA CD or DVD is a disc. They encode binary data in the form of physical pits and lands.\r\n\r\n![inside_disc_close](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch4/inside_disc_close.png)\r\n\r\nA disc drive reads the binary code by shooting a laser at the disc as it spins. The laser will bounce directly back if it hits a land - this means the binary data is reading 1 (or on). If the laser hits a pit the laser will bounce away and this means 0 (or off).\r\n\r\n![inside_disc_level](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch4/inside_disc_level.png)\r\n\r\nThe code is sent to the CPU and the CPU follows those instructions like play the music or movie. It is a very fast and fascinating process - but most things inside computers are very fast and fascinating.\r\n\r\nGood, now we know what is inside a computer and why. Let's move on.\r\n\r\n## Using a Computer\r\n\r\nA computer has stuff stored in its memory and that stuff is called software. Is it software because it is soft, no, its just not hardware. And its just a bunch of code, really that's it.\r\n\r\nRemember Robo? In the beginning, he had computer programs stored in his flash memory - that was software and that was just code.\r\n\r\nSo where should we start? Well at the start. At the point where you press the on button. We call this booting up.\r\n\r\n![using_boot](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_boot.png)\r\n\r\nIf we watch the screen when we press the power button we will see some interesting stuff. We might see some budget looking text and maybe an image. This will go away and a little while later a familiar logo will come up and then we will end up at our fancy login screen. We have experienced an important process.\r\n\r\nWhat happened was everything - before then there was nothing.\r\n\r\nThat first budget looking part is the BIOS. It is a kind of software called firmware that checks hardware and gets it ready to go. It is the first piece of software to run and usually is stored on flash memory. Didn't Robo have some free flash memory?\r\n\r\n\t$ write BIOS to Flash Memory\r\n    Writing data...\r\n    Complete!\r\n\r\nNow that Robo has a BIOS we can plug him into a screen and something will show up.\r\n\r\n![using_plugin](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_plugin.png)\r\n\r\n![using_bios](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_bios.png)\r\n\r\nWe are looking at the BIOS but nothing else happened. Where is our fancy stuff? What we were expecting to show up next is called an operating system (OS).\r\n\r\nAn OS is all of that software we know and love. Windows, OS X and Linux are all popular operating systems. The second job of the BIOS is to run the OS which is usually stored on a hard drive. We need to install an OS on Robo's hard drive.\r\n\r\n\t$ install OSRobo\r\n    Warning: This will erase everything on the hard drive\r\n    Do you wish to continue? Yes\r\n    Installing OS...\r\n    Complete!\r\n\r\n    Rebooting Robo...\r\n\r\n![using_bios](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_bios.png)\r\n\r\nWe are back at the BIOS. RoBIOS does not automatically run an OS, it let's us choose which OS we want to run. We can do this on any computer by pressing a special key like ESC or F8 on boot. We can boot different OSes from our hard drive or even boot an entire operating system from a USB stick.\r\n\r\n![using_bios_os](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_bios_os.png)\r\n\r\n![using_os](file:///E:/aaron/Documents/My%20Documents/COMPSCI%20101/Images/using_os.png)\r\n\r\nThis is the desktop of OSRobo. It has a few good programs already on it: a file manager, web browser, text editor and terminal.\r\n\r\n![using_os_mouse](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_os_mouse.png)\r\n\r\n![using_os_files](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_os_files.png)\r\n\r\nThis is our file manager where we can find our documents and pictures.\r\n\r\n![using_os_files_os](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_os_files_os.png)\r\n\r\nThis is everything. Everything inside these folders is our operating system. There are folders inside of these folders and files inside of the folders. Basically an OS is a bunch of files and those files are full of code - even all of this fancy stuff we are looking at. Let's prove this.\r\n\r\n![using_os_cmd](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_os_cmd.png)\r\n\r\nThis is our OS with all of the fancy graphics removed. We are sitting at what is called the command line. It is a text based interface that let's you do anything on your computer that you would normally do. We get around the command line by typing in commands and pressing enter. We have actually used it a lot already. It is how we updated and installed things to Robo earlier and had a dollar sign at the beginning.\r\n\r\nThe `ls` command lists the contents of the directory.\r\n\r\n\t$ ls\r\n\tSystem Home Boot\r\n\r\n\r\n\r\nThese are the folders we saw before in our file manager. Folders are also called directories. Right now we are in the root directory which if we imagine everything as a tree, we are at the lowest root where everything else will branch out from.\r\n\r\n![using_tree](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_tree.png)\r\n\r\nThe `cd` command changes into the a directory of our choosing.\r\n\r\n\t$ cd Home\r\n    $ ls\r\n    Documents Pictures Videos\r\n\r\n![using_tree_home](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_tree_home.png)\r\n\r\n\t$ cd Documents\r\n    $ ls\r\n\r\nWhen nothing happens with `ls` it means the directory is empty.\r\n\r\n\t$ edit text.txt\r\n    -------------------------\r\n    editor: press Esc to save\r\n    -------------------------\r\n\r\nWe just ran the text editor program `edit` and created a new text file `text.txt`.\r\n\r\n    -------------------------\r\n    editor: press Esc to save\r\n    -------------------------\r\n    Hello World\r\n\r\n<br>\r\n\r\n\t$ ls\r\n    text.txt\r\n\r\n![using_tree_text](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_tree_text.png)\r\n\r\nThe directory is no longer empty as our file is there now. Let's return to the graphical desktop.\r\n\r\n![using_os_files_os2](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_os_files_os2.png)\r\n\r\n![using_os_files_home](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_os_files_home.png)\r\n\r\n![using_os_files_text](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_os_files_text.png)\r\n\r\nBack on the graphical desktop we can see that our new file exists here too.\r\n\r\n![using_os_edit](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_os_edit.png)\r\n\r\nWe have opened our file in the text editor and we can see what we wrote in it before.\r\n\r\n![using_os](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_os.png)\r\n\r\n![using_os_terminal](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_os_terminal.png)\r\n\r\nThis is the command line but inside a nice graphical program that we can use on the desktop.\r\n\r\n\t$ ls\r\n    System Home Boot\r\n    $ cd Home\r\n    $ ls\r\n    Document Pictures Videos\r\n    $ cd Documents\r\n    $ ls\r\n    text.txt\r\n\t$ del text.txt\r\n    $ ls\r\n\r\nWe deleted our file and now have an empty directory again.\r\n\r\nOur text file ended in .txt, this labelled it as a text file and when we opened it with the text editor we could read it because the text editor software was built to handle plain text files.\r\n\r\nThere are a lot of file types like .doc, .jpg, .pdf, .html, and different software programs know how to decode the text written in them. Putting .doc at the end of a file doesn't do anything to the code, but it does automatically try and open it with a piece of software that knows what to do with the code .doc files are written in.\r\n\r\nLet's do something cool with a file.\r\n\r\n\t$ edit hello.html\r\n    -------------------------\r\n    editor: press Esc to save\r\n    -------------------------\r\n\t<!DOCTYPE html>\r\n\t<body>My web page!</body>\r\n\r\nAn HTML file is what a web browser reads and ends in .html. HTML is a markup language used to create web pages that we are going to learn a lot about later. We just wrote a very basic HTML file.\r\n\r\n    $ browser hello.html\r\n    Runnning browser software...\r\n\r\n![using_os_browser](https://raw.githubusercontent.com/compscinz/compscinz.github.io/master/images/ch5/using_os_browser.png)\r\n\r\nThat is our web page! It only exists locally on Robo right now. It will take a bit more to get in online but it is a great start.\r\n\r\nGood, now we know about software from boot up to desktop. Let's move on.\r\n\r\n## Programming\r\n\r\nThis chapter is not finished for this version of the course. In the final version we would be working through Robo Language 2.0 and discovering the key elements of any programming language:\r\n\r\n* Comments\r\n* Printing\r\n* Variables\r\n* User Input\r\n* Math Operators\r\n* Comparators\r\n* Functions\r\n* If Else\r\n* Loops\r\n* Lists\r\n* Classes\r\n* File IO\r\n* Language Intricacies\r\n\r\nInstead we will head over to CodeMonkey (http://www.playcodemonkey.com) and work through the first 30 levels included in their free trial. CodeMonkey is a web application that uses CoffeeScript - an easy-to-use language that compiles to Javascript, the language of the web. We will learn the basics there.\r\n\r\nThen we will sign up for Codecademy (http://www.codecademy.com) and begin to work through their language introductory courses. We will learn the basics of some very popular programming langauges and skills: Python, HTML/CSS, JavaScript, Command Line.\r\n\r\nThis will set us up well for this different programming tasks, including:\r\n\r\n* Create a Q&A machine that takes user input and gives information back.\r\n* Build a text-based calculator.\r\n* Make a text-based role playing game.\r\n* Make a text-based two-player game of noughts and crosses.\r\n* Build a local website.\r\n* Blink some LEDs using electronics.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}